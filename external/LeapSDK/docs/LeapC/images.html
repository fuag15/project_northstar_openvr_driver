<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Leap Motion C API: Images</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="leapmotion-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Leap Motion C API
   &#160;<span id="projectnumber">4.1.0</span>
   </div>
   <div id="projectbrief">The API to the LeapC library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>LeapC</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li class="current"><a href="pages.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('images.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Images </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#usingimages">Using Images</a><ul><li class="level2"><a href="#imagebuffersize">Image Buffer Size</a></li>
</ul>
</li>
<li class="level1"><a href="#imagedistortion">Image Distortion</a><ul><li class="level2"><a href="#rectifypoints">Rectifying Image Points</a></li>
<li class="level2"><a href="#rectifywithshader">Rectifying with a Shader</a></li>
<li class="level2"><a href="#distortionchanges">Detecting when the Distortion Map Changes</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>The Leap Motion controller uses infrared stereo cameras as tracking sensors. The LeapC API provides an image buffer containing the sensor brightness values and a distortion buffer containing the camera calibration map. The distortion map can be used to correct lens distortion in the image data. The function <a class="el" href="group___functions.html#ga0f8c7bb9c7d46fed78efe183244f9812" title="Provides the point in the image corresponding to a ray projecting from the camera. ">LeapRectilinearToPixel()</a> can be used to undistort specific pixels in an image and the function <a class="el" href="group___functions.html#gacc6a5c80f87a60c63889407a45a3344b" title="Provides the corrected camera ray intercepting the specified point on the image. ">LeapPixelToRectilinear()</a> can be used to find the 3D location corresponding to a matched pair of stereo pixels.</p>
<h1><a class="anchor" id="usingimages"></a>
Using Images</h1>
<p>Images are sent automatically if the policy for images is set.</p>
<p>When a stereo image pair is available, a <a class="el" href="group___structs.html#struct_l_e_a_p___i_m_a_g_e___e_v_e_n_t" title="Streaming stereo image pairs from the device. ">LEAP_IMAGE_EVENT</a> is added to the event queue and can be accessed via <a class="el" href="group___functions.html#ga2a8aecad339f0fd339ca22a3e7b389f6" title="Polls the connection for a new event. ">LeapPollConnection()</a>. The image event contains image properties, distortion correction data, and a pointer to the buffer.</p>
<p>Both images from the stereo cameras are written to the same buffer; left image first and then the right image.</p>
<p>To get an image:</p>
<ol type="1">
<li>Open the connection.</li>
<li>Set image policy.</li>
<li>Poll for images.</li>
<li>Continue polling for image frames (optionally also poll for tracking frames and status messages). When an image is available, a <a class="el" href="group___structs.html#struct_l_e_a_p___i_m_a_g_e___e_v_e_n_t" title="Streaming stereo image pairs from the device. ">LEAP_IMAGE_EVENT</a> message is provided by <a class="el" href="group___functions.html#ga2a8aecad339f0fd339ca22a3e7b389f6" title="Polls the connection for a new event. ">LeapPollConnection()</a>. The <a class="el" href="group___structs.html#struct_l_e_a_p___i_m_a_g_e___e_v_e_n_t" title="Streaming stereo image pairs from the device. ">LEAP_IMAGE_EVENT</a> struct contains the images, a description of the images, and the distortion map.</li>
</ol>
<h2><a class="anchor" id="imagebuffersize"></a>
Image Buffer Size</h2>
<p>The image buffer size depends on the device type as well as the image type and format. The buffer size depends on the width, height, and pixel format (bytes per pixel) of the image. A single buffer must hold stereo images. For example, if the current images produced by a Leap Motion device is 640x240, 1-byte pixels, then the buffer size must be: 640 x 240 x 1 x 2 = 307,200 bytes.</p>
<h1><a class="anchor" id="imagedistortion"></a>
Image Distortion</h1>
<p>When a ray of light enters one of the Leap Motion cameras, the lens bends the ray so that it hits the sensor, which records it as a greyscale brightness value at a specific pixel location. Of course, no lens is perfect, so a ray of light does not land on the sensor in the optically perfect spot. The distortion map provides data to correct this imperfection, allowing you to calculate the true angle of the original ray of light. You can use the corrected angle to generate a rectified image, and, using the angles from both images in the stereo pair, you can triangulate the 3D location of a feature identified in both images.</p>
<p>For image rectification, the distortion map can be fed to a shader program that can efficiently interpolate the correction applied to rays of light to produce a texture containing the rectified image. For getting the true angle for a small set of points, you can use the <a class="el" href="group___functions.html#gacc6a5c80f87a60c63889407a45a3344b" title="Provides the corrected camera ray intercepting the specified point on the image. ">LeapPixelToRectilinear()</a> function (but this is not typically efficient enough to transform a full bitmap at a high frame rate).</p>
<h2><a class="anchor" id="rectifypoints"></a>
Rectifying Image Points</h2>
<p>To rectify individual points in an image, you can call the <a class="el" href="group___functions.html#ga0f8c7bb9c7d46fed78efe183244f9812" title="Provides the point in the image corresponding to a ray projecting from the camera. ">LeapRectilinearToPixel()</a> function. Given a ray from the camera, this function returns the pixel coordinates in the image buffer that contain the light recorded from that direction, corrected for lens distortion.</p>
<p>The following code takes a target texture size and determines the correct pixel brightness value. For each pixel, the code computes the ray direction to the point in the scene that would illuminate the target pixel given an ideal optical system. The code then corrects for optical distortion by calling <a class="el" href="group___functions.html#ga0f8c7bb9c7d46fed78efe183244f9812" title="Provides the point in the image corresponding to a ray projecting from the camera. ">LeapRectilinearToPixel()</a>, which provides the pixel coordinates in the image buffer that actually contains the brightness value for the target pixel. The code copies the brightness value to the target texture buffer. The result is a rectified image.</p>
<div class="fragment"><div class="line"><span class="comment">//The pixel size of the textures we write the undistorted images to</span></div><div class="line"><span class="preprocessor">#define TEX_WIDTH 400</span></div><div class="line"><span class="preprocessor">#define TEX_HEIGHT 400</span></div><div class="line"><span class="comment">//Max field of view varies by device, use 8 for the peripheral, 22 for Rigel</span></div><div class="line"><span class="preprocessor">#define MAX_FOV 22</span></div><div class="line"></div><div class="line"><span class="comment">//image_buffer contains the image data</span></div><div class="line"><span class="keywordflow">for</span>( <span class="keywordtype">float</span> row = 0; row &lt; TEX_HEIGHT; row++ ) {</div><div class="line">  <span class="keywordflow">for</span>( <span class="keywordtype">float</span> col = 0; col &lt; TEX_WIDTH; col++ ) {</div><div class="line">    <span class="comment">//Normalize from pixel xy to range [0..1]</span></div><div class="line">    <a class="code" href="group___structs.html#struct_l_e_a_p___v_e_c_t_o_r">LEAP_VECTOR</a> input;</div><div class="line">    input.<a class="code" href="group___structs.html#afd00ac5b6e0991df902b759e576dd14a">x</a> = col/TEX_WIDTH;</div><div class="line">    input.<a class="code" href="group___structs.html#a38a094824b34f895659e7fec297db4ba">y</a> = row/TEX_HEIGHT;</div><div class="line"></div><div class="line">    <span class="comment">//Convert from normalized [0..1] to ray slopes</span></div><div class="line">    input.<a class="code" href="group___structs.html#afd00ac5b6e0991df902b759e576dd14a">x</a> = (input.<a class="code" href="group___structs.html#afd00ac5b6e0991df902b759e576dd14a">x</a> - .5) * MAX_FOV;</div><div class="line">    input.<a class="code" href="group___structs.html#a38a094824b34f895659e7fec297db4ba">y</a> = (input.<a class="code" href="group___structs.html#a38a094824b34f895659e7fec297db4ba">y</a> - .5) * MAX_FOV;</div><div class="line"></div><div class="line">    <a class="code" href="group___structs.html#struct_l_e_a_p___v_e_c_t_o_r">LEAP_VECTOR</a> pixel = <a class="code" href="group___functions.html#ga0f8c7bb9c7d46fed78efe183244f9812">LeapRectilinearToPixel</a>(*connection, <a class="code" href="group___enum.html#gga2bbde1c3af778eba35f0b1a8cf1338c2acb561685872ba1a352c2eb8b5898eb32">eLeapPerspectiveType_stereo_left</a>, input);</div><div class="line">    <span class="keywordtype">int</span> dindex = (int)floor(row * TEX_WIDTH + col);</div><div class="line">    <span class="keywordtype">int</span> pindex = (int)roundf(pixel.<a class="code" href="group___structs.html#a38a094824b34f895659e7fec297db4ba">y</a>) * image_width + (int)roundf(pixel.<a class="code" href="group___structs.html#afd00ac5b6e0991df902b759e576dd14a">x</a>);</div><div class="line">    <span class="keywordflow">if</span>(pixel.<a class="code" href="group___structs.html#afd00ac5b6e0991df902b759e576dd14a">x</a> &gt;= 0 &amp;&amp; pixel.<a class="code" href="group___structs.html#afd00ac5b6e0991df902b759e576dd14a">x</a> &lt; image_width &amp;&amp; pixel.<a class="code" href="group___structs.html#a38a094824b34f895659e7fec297db4ba">y</a> &gt;=0 &amp;&amp; pixel.<a class="code" href="group___structs.html#a38a094824b34f895659e7fec297db4ba">y</a> &lt; image_height){</div><div class="line">      undistorted_image_left[dindex] = ((<span class="keywordtype">char</span>*)image_buffer)[pindex];</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">      undistorted_image_left[dindex] = 128;</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>For the right image, remember to offset the index into the image_buffer array since the right image follows the left.</p>
<p>You can get the actual device field of view from the <a class="el" href="group___structs.html#struct_l_e_a_p___d_e_v_i_c_e___i_n_f_o" title="Properties of a Leap device. ">LEAP_DEVICE_INFO</a> struct. Use tan(fov/2) in the calculation above instead of MAX_FOV.</p>
<p>Note that <a class="el" href="group___functions.html#ga0f8c7bb9c7d46fed78efe183244f9812" title="Provides the point in the image corresponding to a ray projecting from the camera. ">LeapRectilinearToPixel()</a> may not be fast enough to rectify the image to a high resolution texture in real-time. Generally you should limit its use to individual points, image patches, or low-resolution textures. For better performance for full images, you can use a shader to rectify the image.</p>
<p>See <a class="el" href="glut-rectify-example.html">Rectifying Points Example</a></p>
<h2><a class="anchor" id="rectifywithshader"></a>
Rectifying with a Shader</h2>
<p>To rectify an entire image with a shader, create a texture containing the data in the distortion buffer. The distortion buffer is contained in the distortion_matrix field of the <a class="el" href="group___structs.html#struct_l_e_a_p___i_m_a_g_e___e_v_e_n_t" title="Streaming stereo image pairs from the device. ">LEAP_IMAGE_EVENT</a> struct. This data is set up to use a shader's normal uv interpolation mechanism. You can use the interpolated uv coordinates to look up the corrected brightness in the image texture, as in the following fragment shader program:</p>
<div class="fragment"><div class="line">uniform sampler2D rawTexture;</div><div class="line">uniform sampler2D distortionTexture;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">  vec2 distortionIndex = texture2D(distortionTexture, gl_TexCoord[0].st).xy;</div><div class="line">  <span class="keywordtype">float</span> hIndex = distortionIndex.r;</div><div class="line">  <span class="keywordtype">float</span> vIndex = distortionIndex.g;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span>(vIndex &gt; 0.0 &amp;&amp; vIndex &lt; 1.0 &amp;&amp; hIndex &gt; 0.0 &amp;&amp; hIndex &lt; 1.0)</div><div class="line">  {</div><div class="line">    gl_FragColor = vec4(texture2D(rawTexture, distortionIndex).rrr, 1.0);</div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    gl_FragColor = vec4(0.2, 0.0, 0.0, 1.0);</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>To interpolate correctly, the distortion texture must use the following filter and wrap parameters:</p>
<div class="fragment"><div class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</div><div class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</div><div class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);</div><div class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);</div></div><!-- fragment --><p>The distortion texture itself must use two floating point values per texel and contain 64x64 texels:</p>
<div class="fragment"><div class="line">glTexImage2D(GL_TEXTURE_2D, 0, GL_RG, 64, 64, 0, GL_RG, GL_FLOAT, distortion_buffer_left);</div></div><!-- fragment --><p>The distortion map itself rarely changes &ndash; the only time it changes is if the Leap Motion hardware is swapped with a different device or if the device is rotated so that the user's hands enter from the opposite side of the vertical field of view. In this case the Leap Motion software inverts the image, and the distortion map, to automatically maintain the proper orientation. (Auto-orientation can be turned off in the Leap Motion service configuration.)</p>
<p>See <a class="el" href="glut-shader-example.html">Rectifying with a Shader Example</a></p>
<h2><a class="anchor" id="distortionchanges"></a>
Detecting when the Distortion Map Changes</h2>
<p>The distortion map contains a grid of values that can be used to rectify the images. Rectification should be performed if you are aligning 3D objects with pixels in the images or if you are performing stereo triangulation on the image pair.</p>
<p>Each image complete event contains the distortion map for that image, however, since translating the map to an interpolation array or shader texture can itself be an expensive task, you typically only want to do this when the distortion map actually changes &ndash; not once for every image request. The distortion map can only change when the images are flipped due to automatic or manual re-orientation or if the device itself is changed. (For internal reasons) there is no way to tell that a reorientation has occurred. However, you can use the LEAP_IMAGE_EVENT::matrix_version field to detect when the distortion map changes. When the matrix_version changes between images, you know that the distortion map has changed. The matrix version number ALWAYS increases when the distortion map changes and never returns to a prior value.</p>
<p>See <a class="el" href="glut-shader-example.html">Rectifying with a Shader Example</a> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">LeapC Guide</a></li>
    <li class="footer">Generated on Wed Aug 12 2020 09:47:25 for Leap Motion C API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
